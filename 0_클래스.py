# -*- coding: utf-8 -*-
"""0. 클래스.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zw4hrNw91l_uSVgYd13Zehh6381swMJr

# 개요

- s/w 개발 방식
  - 절차적 프로그래밍
    - C/C++, Python, javascript...
      - 코드의 재사용성을 구현하기 힘들다
  - 함수 지향적 프로그래밍
    - 절차적(타입, 자료구조, 조건/제어/반복문) + 함수
    - C/C++, Python, javascript...
    - 최근 다시 유행하고 있다(리액트)
  - 객체 지향적 프로그래밍
    - C/C++, Python, javascript, kotlin, swift, scalar
    - 절차적 + 함수 + class 개념
      - 객체 지향 프로그래밍
        - 상속성, 다형성, 은닉성 3가지 특성이 있어야 한다
      - GUI 프로그램(윈도우 & IOS)
        - pyQT5

# Class

- 개념
  - entity
    - 이 세상에 존재하는 모든 개념(무형), 유형(실존하는 것)
    - 이런 entity를 컴퓨터 사이언스, 프로그래밍에서는 entity를 표현하기 위해서는 도구가 필요하다 => class라는 문법을 가지고 구현
  - class
    - 문법이 존재하고, entity를 표헌하는 도구
    - 클래스를 작성 -> 실행 -> 클래스 생성자를 호출
    - 클래스의 모습을 본딴 형태로 메모리에 저장 => 객체(object)
    - 클래스의 인스턴스를 객체라고 부른다
      - 여러개를 만들 수도 있다
    - 객체의 청사진은 클래스라고 한다
  - object
    - 프로그램이 작동하면 메모리상에 존재
    - 주소가 존재 => (0x7f561cdc2d90)
    - 특정 변수가 그 객체를 받아주면 그 변수를 객체라고 부른다
    - 특정 객체를 가리키는 주소를 가진다

# Object

- 모든 클래스(이미 만들어져 있거나, 내가 만들거나)의 부모 클래스이다

# 문법
"""

# 클래스 정의 
class Person :
  pass

# 클래스 사용 -> 객체 생성
p = Person()

# p를 통해서 Person 객체로 접근 할 수 있다
p

# 해제
del p

# p

"""# 클래스 구성원
- 생성자
- 맴버
  - 변수
    - 접근제어를 표현할 수 있을 때 언급
  - 함수
- 소멸자
- 기타 _로 시작하는 사전 정의된 함수들
- 정적함수

"""

# 멤버 -> 클래스 소속이다 -> 객체명.멤버변수 or 객체명.멤버함수
# Person 클래스 내부에서 자기 자신을 표현할 때 => self or(타 언어는 this)

# 부모 클래스를 명시적으로 표현하지 않아도 이미 Object(모든 클래스의 수퍼클래스)를 상속하고 있다
# class Person(Object):
class Person :
  # 생성자 (생략 가능함 -> 부모 생성자가 있으니까? 그것을 그대로 사용)  
  # 멤버 변수
  p = 0.2
  # 멤버 함수
  def getP(self) :
    return self.p

per = Person()

# 객체명.멤버변수
per.p

# 객체명.멤버함수
per.getP()

"""# 상속

- 부모 클래스로부터 모든 유산를 받아서 자식 클래스는 사용 가능
- 부모로 부터 받은 유산을 재정의해서 사용 가능
- 자식 클래스는 별로도 새로운 기능을 만들어서 추가할수 있다
- XMan > Person > Object
  - XMan은 Object 이다 (is a)
  - Object는 자식으로 XMan을 가진다 (has a) 
"""

class XMan(Person) :
  def attack(self) :
    print('하늘을 나는 능력을 추가했다')
x = XMan()

x.p, x.getP(), x.attack()