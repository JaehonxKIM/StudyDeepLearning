# -*- coding: utf-8 -*-
"""1. 텐서플로우_기초학습.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zcnsU2IFP_-FPxe3vESTY4D5WXfFzUfi

# 기본구성

- 텐서플로우 1.x, 2.x 확인
"""

!pip list

!pip install tensorflow==1.15

# Commented out IPython magic to ensure Python compatibility.
# %tensorflow_version 1.x

import tensorflow as tf
tf.__version__

"""# Define And Run

- 2개의 파트로 설계하여 개발 운영된다
  - 설계
    - 데이터가 흘러들어가는 플로우를 구성
    - 신경망 구성
    - 네트워크 구성
    - 파이썬으로 구성
    - 실제 연산작업은 수행하지 않는다 
  - 학습
    - 실제 데이터 주입
    - 데이터를 가지고 C++이 실제 학습행위 진행
      - 빠르다
    - 세션을 획득 후 학습이 진행
    - 절차
      - 세션 Open
      - 데이터 주입
      - 학습 진행(C++)/ GPU활용
      - 결과를 돌려받음
      - 세션 Close
  
  - 텐서보드를 활용해서 플로우 및 기타 내용을 학인할 수는 있다

# 텐서플로우 기본 요소

## Tensor

- 연산의 기본단위, 데이터의 기본단위
- 본질은 **행렬**
- **numpy 기반**으로 구현되어 있다
- ndarray와 tensor간에는 거의 유사한 함수들이 존재
- 데이터는 무조건 모조리 다 **수치**로 표시되어 있다
- **하나의 텐서 안에 있는 데이터는 모두 같은 타입이어야 한다**
"""

from IPython.core.display import Image
Image('/content/drive/MyDrive/ComputerProgramming/DeepLearning/2.딥러닝/dl/텐서용어.png')

Image('/content/drive/MyDrive/ComputerProgramming/DeepLearning/2.딥러닝/dl/tensor_style.jpeg')

"""## 상수(Constant)

- 초기값 부여용도
- <tf.Tensor 'Const:0' shape=() dtype=int32>

"""

# 1.플로우 구성
myText = tf.constant(10)
myText

type(myText)

# 2. 실행 => 실제 10이 세팅되고 사용된다
# 2-1. 세션 오픈
sess = tf.Session()

# 2-2. 데이터 주입, 실행
result = sess.run(myText)

# 2-3. 세션 닫기
sess.close()

result

"""## 연산"""

# part1. 플로우 구성
a = tf.constant(1234)
b = tf.constant(4000)

a, b

# 계산식 => add_oper는  a + b의 결과이다(결과만 가진 상태)
add_oper = a + b
add_oper

# part2. 데이터 주입 후 실행 => I/O
with tf.Session() as sess :
  print(sess.run(add_oper))

"""## 변수(Variable)"""

# 해당 텐서의 정채성을 정확하게 묘사 -> 텐서보드에서 플로우를 볼 때 구분이 용이함
# a : 0
a = tf.constant(1234, name = 'a')
b = tf.constant(4000, name = 'b')
c = tf.constant(4000, name = 'c')

a, b, c

# 변수 => 가중치, 편향값
v = tf.Variable(0, name = 'v')
v

# 연산 
x_opr = a + b - c
x_opr

# 데이터 플로우 그래프(데이터들간의 관계 -> 그래프)
assign_opr = tf.assign(v, x_opr)
assign_opr

# 데이터 주입 후 실행 => I/O
with tf.Session() as sess :
  print(sess.run(assign_opr))
  print(sess.run(v))

"""## 플레이스 홀더(PlaceHolder)

- 데이터를 주입할 때 대상이 되는 요소
- 신경망을 구성하고 학습을 전개할 때 데이터를 삽입하는데, 그 형태(shape)등등 PlaceHolder를 기준으로 설계
- shape이 중요
- 종류
  - 고정크기 PlaceHolder
  - 가변크기 PlaceHolder

### 고정크기 플레이스 홀더
"""

# part1. 데이터플로우그래프 구성 
# 데이터는 정수, 값이 3개로 구성된 1차원 벡터형태로 주입해야 한다
a = tf.placeholder(tf.int32, shape = (3,))
a

# 상수
b = tf.constant( 2 )
b

# 연산
# 백터 + 스칼라 => 백터의 모든 요소에 스칼라값을 일일이 더한다
x_opr = a + b 
x_opr

# part2. 데이터 주입 및 실행
# 데이터 주입 => feed_dict를 채우면 된다
# 값은 딕셔너리
# 키는 placeholder를 지칭하는 변수병 => a
# 값은 placeholder에서 정의한대로 벡터의 형태(배열, 리스트), 1차원, 정수
with tf.Session() as sess :
  print(sess.run(x_opr, feed_dict = { a : [1,2,3]}))

"""### 가변크기 플레이스 홀더

- 실제 학습시 형태
- 데이터의 개수가 몇개인지 모를 때 가변적일 때
"""

a = tf.placeholder(tf.int32, shape = (None,))
b = tf.constant( 2 )
x_opr = a + b 
with tf.Session() as sess :
  print(sess.run(x_opr, feed_dict= {a : [1,2,3]}))
  print(sess.run(x_opr, feed_dict= {a : [1,2,3,4,5,6,7,8]}))
  print(sess.run(x_opr, feed_dict= {a : [1]}))